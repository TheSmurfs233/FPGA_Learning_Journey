# 灰度图像显示

## 1. 理论知识

### 1.1 图像灰度简介

​	灰度图像是 R、G、B 三个分量相同的一种特殊的彩色图像,其一个像素点的变化范围为 0~255。因此,灰度图像只能表现 256 种颜色(或亮度)。通常把灰度图像中像素的亮度称为灰度值。

​	灰度数字图像是每个像素只有一个采样颜色的图像。这类图像通常显示为从最暗黑色到最亮的白色的灰度,尽管理论上这个采样可以任何颜色的不同深浅,甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同,在计算机图像领域中黑白图像只有黑白两种颜色,灰度图像在黑色与白色之间还有许多级的颜色深度。

### 1.2 灰度处理的方式

​	灰度化处理的方法有很多种方法,经常使用的方法主要有如下三种:

1. 最大值法:使 R、G、B 的值等于三个值中最大的一个,即: R = G = B = max(R,G,B)用最大值法对彩色图像进行灰度化处理会使图像的整体亮度增强。

2. 平均值法:对 R、G、B 求出平均值,即:
   $$
   R = G = B = (R,G,B) / 3
   $$
   采用平均法对彩色图像进行灰度化处理会形成比较柔和的灰度图像。

3. 加权平均值法:根据三种基色的重要性或其他指标给 R、G、B 赋予不同的权值,即:
   $$
   R = G = B = (Wr*R + Wg*G + Wb*B)/(Wr + Wg + Wb)
   $$
   其中,Wr、Wg、Wb 分别为 R、G、B 的权重。

   取不同的值,加权平均值法将形成不同的灰度图像。由于人眼对绿色的敏感度最高,对红色的敏感度次之,对蓝色的敏感度最低,因此使 Wg > Wr > Wb 将得到比较合理的灰度图像。实验和理论推导证明,Wr = 0.299、Wg = 0.587、Wb = 0.114 时效果最佳,即:
   $$
   R = G = B = (0.299R + 0.587G + 0.114B)/( 0.299 + 0.587 + 0.114) 
   \\= 0.299R + 0.587G +0.114B
   $$
   上式中有除法,考虑到在 gray FPGA i, j 中实现除法比较的消耗资源,这里在实现前可以先做如下的近似处理。
   $$
   R=G=B= (0.299R + 0.587G +0.114B)*256/256
   \\=(76R+150G+30B)>>8
   $$
   

### 1.3 YUV色域

​	YUV,是一种颜色编码方法。常使用在各个视频处理组件中。YUV 在对照片或视频编码时,考虑到人类的感知能力,允许降低色度的带宽。

​	YUV 是编译 true-color 颜色空间的种类,Y'UV, YUV, YCbCr,YPbPr 等专有名词都可以称为 YUV,彼此有重叠。“Y”表示明亮度(Luminance、Luma),“U”和“V”则是色度、浓度(Chrominance、Chroma)。

​	RGB 转 YUV转换公式如下:
$$
Y = 0.299*R + 0.587*G + 0.114*B
\\U = -0.169*R – 0.331*G + 0.5*B + 128
\\V = 0.5*R – 0.419*G – 0.081*B + 128
$$
​	YUV 转 RGB 转换公式如下:
$$
R = Y + 1.13983*(V - 128)
\\G = Y – 0.39465*(U - 128) – 0.58060*(V - 128)
\\B = Y + 2.03211*(U - 128)
$$


## 2. 程序设计

### 2.1 rgb2gray 模块

可以看到模块的代码非常简洁,模块输入为 RGB,输出为 GRAY。然后定义了一些变量,用于公式计算。因为 FPGA 计算浮点数不方便,因此将公式整体放大 8 倍,计算完成后我们再将结果右移 8 bit,即缩小 8 倍,这样既得出了结果,也方便 FPGA 进行计算。

```
`timescale 1ns / 1ps


//     Gray = R*0.299 + G*0.587 + B*0.114
//     Gray = (R*76 + G*150 + B*30) >> 8    使用8位精度来进行运算

module rgb2gray
#(
    parameter  Pixel_Width = 16
)
(
    input                         I_clk,
    input                         I_reset_p,
    input                         I_pixel_data_valid,
    input  [Pixel_Width-1:0]      I_pixel_data_RGB,//RGB 888 [23-16,15-8,7-0]
    output reg                    O_pixel_data_valid,
    output [7:0]                  O_pixel_data_Gray

);

reg  [14:0] R_mult;// 7bit * 8 bit
reg  [15:0] G_mult;//8bit * 8bit
reg  [14:0] B_mult;//5bit * 8bit
reg  [16:0] gray_temp;
reg         pixel_data_valid_d1; 


wire [7:0]  RGB_R;
wire [7:0]  RGB_G;
wire [7:0]  RGB_B;

assign  RGB_R = {I_pixel_data_RGB[15:11],I_pixel_data_RGB[13:11]};
assign  RGB_G = {I_pixel_data_RGB[10:5],I_pixel_data_RGB[6:5]};
assign  RGB_B = {I_pixel_data_RGB[4:0],I_pixel_data_RGB[2:0]};

always@(posedge I_clk)
   begin
      if(I_reset_p)
         begin
            R_mult <= 'h0;
            G_mult <= 'h0;
            B_mult <= 'h0;            
         end
      else
         begin
            R_mult <= RGB_R * 76;
            G_mult <= RGB_G * 150;
            B_mult <= RGB_B * 30;            
         end
   end

always@(posedge I_clk)
   begin
      if(I_reset_p)
         gray_temp <=  'h0;
      else
         gray_temp <= R_mult + G_mult + B_mult;
   end
always@(posedge I_clk)
   begin
      pixel_data_valid_d1 <= I_pixel_data_valid;
      O_pixel_data_valid <= pixel_data_valid_d1;
   end

assign    O_pixel_data_Gray = (gray_temp[16])? 8'hff : gray_temp[15:8];// >> 8 bit
   
endmodule


```

