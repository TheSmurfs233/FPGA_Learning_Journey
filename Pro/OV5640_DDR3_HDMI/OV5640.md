# OV5640

## 1. 理论知识

### 1.1 OV5640摄像头介绍

​	OV5640 是由豪威科技生产的一款 1/4 英寸单芯片CMOS图像传感器，其感光阵列达到2592\*1944 (即 500W 像素)，最高支持 2592x1944@15fps（QSXGA）或 640*480@90fps的图像输出。

**模块引脚描述**

​	所使用的OV5640模块提供了一个18PIN的插针接口，如下图

![20PIN的插针接口](asset/OV5640-2.png)

模块各引脚的功能描述如下表所示

| 引脚名称 | 引脚类型 | 引脚功能描述              |
| -------- | -------- | ------------------------- |
| RESET    | 输入     | 系统复位引脚，低电平有效  |
| PWDN     | 输入     | 掉电/省电模式，高电平有效 |
| HREF     | 输出     | 行同步信号                |
| VSYNC    | 输出     | 场同步信号                |
| PCLK     | 输出     | 像素时钟                  |
| SCL      | 输入     | SCCB 总线的时钟线         |
| SDA      | I/O      | SCCB 总线的数据线         |
| LED      | 输入     | LED补光灯引脚             |
| D0...D9  | 输出     | 像素数据端口              |

注意:OV5640 芯片 DVP 接口本身拥有 10 位的数据线,可以输出 10 位的 RAW 数据,但是在大多数情况下,使用高 8 位数据即可,因此模组在设计时,仅使用了 OV5640 芯片的D9~D2 高 8 位,映射到模组上的 OV_D7~OV_D0。

### 1.2 OV5640工作原理

​	OV5640 是一个典型的 CMOS 图像传感器,作为一个图像传感器,其主要作用就是将现实中的各种光线转换为数字系统能够识别的数字信号,光线中三元色各个颜色的强度本身是模拟信号,所以图像传感器的最基本的原理就是进行模数转换,将光线这个模拟量转换为数字信号。

​	自然界中的光,实际上是三种基本单色光的组合,这三种基本单色光为红(RED)、绿(GREEN)、蓝(BLUE),我们称之为三原色。通过将这三种基本颜色按照不同的比例混合,就可以得到其他的任意颜色。例如纯黄色是由红色和绿色按照一比一的比例混合得到的,蓝色量为 0。

​	所以图像传感器里面的模数转换,实质就是对一束光线的三原色的强度进行转换,将三原色中每一种颜色的强度转化为数字信号。再用颜色加数字的方式来表示该束光线的真实颜色。

​	表示颜色的方法最常用的RGB888格式，就是使用 3 个 8 位的数据表示一种颜色,其中高八位表示红色分量,中八位表示绿色分量,低八位表示蓝色分量。如下表所示。

|        | 红       | 绿       | 蓝       | 黄       | 品红     | 青       | 白       | 黑       |
| ------ | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| RGB888 | 0xff0000 | 0x00ff00 | 0x0000ff | 0xffff00 | 0x00ffff | 0xff00ff | 0xffffff | 0x000000 |

​	接下来，我们就需要考虑如何才能对一束自然光中的三原色的强度分别进行模数转换呢?如下图所示，通过加入滤光片,就能让对应颜色的光线通过滤光片到达感光元件。

![使用滤光片对三原色分离](asset/OV5640-3.png)

​	由于一个感光元件只能对一种颜色的光进行感应，所以说对于某一束光线，至少使用3个像素才能把该束光的三种颜色分量全提取出来，实际上 3 个像素间摆放位置又存在物理限制。为了解决这些问题，诞生了著名的拜尔(以下简称 Bayer)矩阵。Bayer 矩阵定义,感光像素矩阵中,奇数行间隔放置绿色和红色感应像素,偶数行间隔放置绿色和蓝色感应像素,奇数列间隔放置绿色和蓝色感应像素,偶数列间隔放置红色和绿色感应像素,其输出数据格式如下图所示。

![拜尔矩阵](asset/OV5640-4.png)

​	根据这种分布规律,在 Bayer 矩阵中,以相邻的四个像素作为一组,在该组中,有两个感应绿色分量的像素呈对角分布,另外两个像素则分别对应感应红色分量和感应蓝色分量。通过这样一种方式,我们可以发现,任取一个像素,其与相邻的 3 个像素组成的矩阵中,总符合这样的规律。不同的只是三种颜色的像素所在的位置的差异。下图为图像传感器手册中给出的像素物理分布图。

![像素物理分布图](asset/OV5640-5.png)

​	而且通过对上述 8*8 的矩阵进行分析发现,在整个矩阵中,像素的位置关系有且只有下
面四种情况:

![OV5640-6](asset/OV5640-6.png)

​	所以,在实际颜色提取时,需要通过数据转换,将相邻四个像素的数据通过插值算法合并为一个 RGB 像素颜色,此种转换算法名为 RAW2RGB,这里取左上角四个像素点的数据为例,具体颜色转换算法如下所示:

​	保留相邻四个像素中的红色和蓝色分量,而对两个绿色分量求平均,得到新的绿色分量,此三种颜色分量组成一个新的 RGB 格式的像素

​	按照这样的思路,整个图像传感器中的每一个像素都可以以不同的角色参与 4 次运算,并最终得到 4 个 RGB 颜色值,所以理论来说,还是可以认为一个图像传感器有多少个物理像素,就能得到多少个 RGB 格式的像素值,虽然每个物理像素都只能感应一种颜色。但是进过插值运算后,其能输出 RGB 的数据格式的像素数量还是等于其物理像素个数的。

**模块功能框图**

![OV5640功能框图](asset/OV5640-1.png)

​	由上图可知,时序发生器(timing generator)控制着感光阵列(image array) 、放大器(AMP) 、AD 转换以及输出外部时序信号(VSYNC、HREF 和 PCLK) ,外部时钟 XVCLK 经过 PLL 锁相环后输出的时钟作为系统的控制时钟;该感光阵列共有 2592\*1944 个物理像素,在感光阵列外围,有一个 row select 功能模块来选择当前输出哪一行的像素,和一个 column sample/hold 电路来依次采样每行像素中的每一个像素的感光元件感应结果(模拟信号)并输出到信号放大器(AMP),经过信号放大器之后进入 10 位 AD 转换器;AD 转换器将模拟信号转化成数字信号,并且经过 ISP 进行相关图像处理,最终输出所配置格式的 10 位视频数据流。增益放大器控制以及 ISP 等都可以通过寄存器(registers)来配置,配置寄存器的接口就是SCCB 接口,该接口协议兼容 IIC 协议。

### 1.3 OV5640 数字信号处理流程

​	影像处理器(ISP) -> 压缩引擎(Compression Engine) -> 格式化处理器(Formatter)

### 1.4 OV5640数字接口

1. 工作时钟

   ​	OV5640 的时钟从 XCLK 引脚输入,该时钟默认固定频率为 24MHz。要想 OV5640能够开始工作,提供该 XCLK 时钟必不可少。

2. 数据流接口

   对于图像传感器来说,常见的数据流接口包括 DVP 接口、LVDS 接口、CSI(MIPI)接口。

   - DVP 接口:

     DVP 接口是最为经典的图像数据流接口,其本质是**一个包含控制信号和数据信号的并行数据端口,使用单端 TTL 电平进行通信**。 DVP 接口包括时钟信号(PCLK)、行有效信号(HREF)、场同步信号(VSYNC)、8 位或更多位的数据信号。

     VSYNC 信号每个高脉冲标志着新一帧图像的开始,在 HREF 为高电平期间,每个 PCLK,8 位 DATA 数据线输出一个数据。下图为 OV5640 输出标准 VGA 分辨率(640*480)图像时候的时序图。

     ![OV5640-7](asset/OV5640-7.png)

     上图,tp 为每一个像素所占用的时钟周期个数,如果输出的是原始的 RAW 格式,则 tp= 1\*PCLK,如果输出的是 RGB 或者 YUV 格式,则 tp=2\*PCLK。也就是说,如果输出的是 RGB或者 YUV 格式,则每行(Row)有 640*2 个字节的数据输出。

   - LVDS 接口:

     随着图像传感器的像素密度越来越高,其输出数据量也大幅增加,由于传统的 DVP 接口采用的是单端 TTL 并行接口,这种接口模式 IO 翻转速率上限受限,当数据量超过一定的值之后,DVP 接口就无法再满足全部数据的传输。为此,能够显著提升数据传输速率的低压差分串行传输接口(LVDS)就应用到了图像传感器的数据流接口上。LVDS 接口采用差分电平传输,每个信号都使用两根信号线传输数据,接收端通过这两根信号线之间的电压差来确定接收到的数据是 0 还是 1, 采用差分传输方式能够显著提升信号线的抗干扰能力,所以 LVDS的传输速率相对较高。图像传感器使用 LVDS 接口传输图像信息,不仅能满足高带宽的通信需求,还能提高信号传输的抗干扰能力。

   - CSI 接口:

     CSI 接口属于 MIPI 接口的一种,全称为摄像机串行接口(Camera Serial Interface),CSI接口物理层使用 LVDS 接口传输,但是在数据内容层发生了变化。 CSI 接口不仅能够传输数据流内容,还能传输控制数据,目前 CSI 接口在多媒体数字终端(手机、平板电脑)等设备中应用非常广泛。

     无论是 DVP 接口,还是 LVDS 接口、CSI 接口,其最终的目的都是将数据输出给应用处理器。具体使用什么接口需要看应用处理器的连接能力。这其中,DVP 接口对应用处理器的IO 能力要求较低,只需要能支持 TTL 电平即可。而 LVDS 接口则需要 IO 口能够提供相应的LVDS 电平以及数据传输能力。CSI 接口,不仅需要应用处理器能够接受 LVDS 电平,还需要能够解码 CSI 协议。现代的各种多媒体处理器大多自带 CSI 功能接口硬件,因此能够直接连接 CSI 接口的图像传感器。而 FPGA 一般支持 DVP 接口和 LVDS 接口,对于 CSI 接口,要支持的话需要有对应的 CSI 协议 IP。所以除非是必须要使用 CSI 接口,否则目前的 FPGA 在连接摄像头时,大多还算使用 DVP 接口和 LVDS 接口。

3.  控制接口

   ​	SCCB(Serial Camera Control Bus,串行摄像头控制总线)是由 OV(OmniVision 的简称)公司定义和发展的三线式串行总线,该总线控制着摄像头大部分的功能,包括图像数据格式、分辨率以及图像处理参数等。OV 公司为了减少传感器引脚的封装,现在 SCCB 总线大多采用两线式接口总线。所谓串行摄像头控制总线,虽然看名字貌似是摄像头的一个专属总线,但是实质上,其就是 I2C 总线的一个小变种而已。 

   ![SCCB时序](asset/OV5640-8.png)

   ​	图中上方为标准 I2C 协议读取一个地址中数据的时序图,下方为 SCCB 协议读取一个地址中数据的时序图,两者的差异以红色线条的形式标记出来。可以看到:对于 I2C 协议,其在执行读的过程中,当第二次传输(word address)传输完成之后,直接产生了新的起始位并开始再一次传输控制字节;对于 SCCB 协议,其在执行读的过程中,当第二次传输(word address)传输完成之后,是先产生了一个停止位,然后再产生新的起始位并开始再一次传输控制字节的。两者仅有此差别。

4.  复位控制

   ![OV5640上电复位时序图](asset/OV5640-9.png)

   手册描述：

   - PWDN 信号为掉电控制信号,当该引脚为高电平时整个图像传感器的模拟和数字部分都处于掉电不工作状态,为低电平时整个器件才可以开始工作;
   -  如果不希望控制 PWDN 信号,则该信号可以直接接到低电平;
   -  如果需要控制 PWDN 信号,则需要在上电至少 5ms 之后再拉低 PWDN。
   -  RESET 信号为复位信号,低电平复位。
   -  RESET 引脚必须在上电稳定后保持 t3(1ms)时间后才能变为高电平让整个系统开始工作。
   -  SCCB 接口工作需要在复位信号拉高 t4(20ms)时间之后才能开始工作
   -  XCLK 信号必须在 SCCB 接口正常工作之前 1ms 就就绪,换句话说,如果 XCLK 没有正常提供,OV5640 的 SCCB 接口也将无法正常的读写寄存器。

### 1.5 OV5640 应用指南

1. 输出图像尺寸

   ​	OV5640 最终输出的图像是经历了开窗、平移、尺寸压缩之后的得到的。下图为 OV5640 输出图像的示意图。

   ![OV5640 输出图像的示意图](asset/OV5640-10.png)

   ​	OV5640 使用 0x3800 ~ 0x3814 寄存器来设置图像窗口,上图显示了寄存器与窗口尺寸定义的关系。物理像素尺寸是整个图像传感器拥有的总的像素矩阵尺寸。ISP 输入尺寸是从像素矩阵中截取的需要读取的像素矩阵部分,一般来讲,ISP 输入尺寸越大,能够达到的最大帧率也就越低。数据输出尺寸是最终从 OV5640 输出的图像尺寸,其大小是在 ISP 输入尺寸的基础上再次经过平移(pre scaling size)和缩放(after scaling)得到的。

2.  ISP 输入窗口设置( ISP input size)

   ​	ISP 输入窗口设置,简称开窗,该设置允许用户设置整个传感器区域( physical pixel
   size )的感兴趣部分,也就是在传感器里面开窗( X_ADDR_ST、Y_ADDR_ST、X_ADDR_END 和 Y_ADDR_END),开窗范围从 0*0~2591*1943 都可以设置,该窗口所设置的范围,将输入 ISP 进行处理。在左侧最大的一圈(标记为 1 )是整个图像传感器的物理像素矩阵,大小为2592*1944;而次外围(标记为 2 )则是通过开窗的方式,从整个物理像素矩阵中截取出的一块图像像素,整个截取的图像范围是可以通过(0x3800~0x3807 寄存器设置的)。下表为0x3800~0x3807 寄存器的功能介绍。

   | 寄存器地址 | 名称      | 默认值 | 功能描述                            |
   | ---------- | --------- | ------ | ----------------------------------- |
   | 0x3800     | TIMING HS | 0x00   | bit[3:0]: X 方向开始位置地址高 4 位 |
   | 0x3801     | TIMING HS | 0x00   | bit[7:0]: X 方向开始位置地址低 8 位 |
   | 0x3802     | TIMING VS | 0x00   | bit[2:0]: Y 方向开始位置地址高 3 位 |
   | 0x3803     | TIMING VS | 0x00   | bit[7:0]: Y 方向开始位置地址低 8 位 |
   | 0x3804     | TIMING HW | 0x0A   | bit[3:0]: X 方向结束位置地址高 4 位 |
   | 0x3805     | TIMING HW | 0x3F   | bit[7:0]: X 方向结束位置地址低 8 位 |
   | 0x3806     | TIMING VH | 0x07   | bit[2:0]: Y 方向结束位置地址高 3 位 |
   | 0x3807     | TIMING HH | 0x9F   | bit[7:0]: Y 方向结束位置地址低 8 位 |

3. 预缩放窗口设置( pre-scaling size)

   ​	该设置允许用户在 ISP 输入窗口的基础上,再次设置将要用于缩放的窗口大小。该设置通过在 ISP 输入窗口内将矩阵的起始位置较 ISP 输入窗口的起始位置进行 (X_OFFSET)
   和 Y(Y_OFFSET)方向的平移。这两个偏移量是通过 0X3810~0X3813 等 4 个寄存器进行设置。至于平移的目的,一种可能就是在镜头机械位置等已经固定的情况下,针对特定应用调整采集到的图像输出的中心位置。注意,该设置仅仅调整的是有效输出区间的左上角的起始位置,没有定义区间的结束位置。

   下表为 0X3810~0X3813 寄存器的功能说明。

   | 寄存器地址 | 名称           | 默认值 | 功能描述                                                     |
   | ---------- | -------------- | ------ | ------------------------------------------------------------ |
   | 0x3810     | TIMING HOFFSET | 0x00   | bit[3:0]: 预缩放窗口 X 方向起始位置相较于 ISP 输入窗口 X 方向的偏移量的高 4 位 |
   | 0x3811     | TIMING HOFFSET | 0x10   | bit[7:0]: 预缩放窗口 X 方向起始位置相较于 ISP 输入窗口 X 方向的偏移量的低 8 位 |
   | 0x3812     | TIMING VOFFSET | 0x00   | bit[2:0]: 预缩放窗口 Y 方向起始位置相较于 ISP 输入窗口 Y 方向的偏移量的高 3 位 |
   | 0x3813     | TIMING VOFFSET | 0x04   | bit[7:0]: 预缩放窗口 Y 方向起始位置相较于 ISP 输入窗口 Y 方向的偏移量的低 8 位 |

   注意,这里的偏移量的大小值是基于 ISP 输入窗口的起始地址的增量,例如,假设 ISP 输入窗口的 X 方向起始位置为 0x0F1、而 X 方向的偏移量值为 0x005,那么最终输出图像的
   X 方向的起始地址就是 0x0F6。Y 方向也是相同的计算方法。

4. 输出大小窗口设置( data output size)

   ​	该窗口是以预缩放窗口为原始大小,经过内部 DSP 进行缩放处理后,输出给外部的图像窗口大小。它控制最终的图像输出尺寸( X_OUTPUT_SIZE/Y_OUTPUT_SIZE)。例如当希望将 OV5640 的图像通过 800*480 的显示屏显示时,就应该设置图像的输出大小窗口尺寸为800*480。输出窗口尺寸大小是通过 0X3808~0X380B 等 4 个寄存器进行设置。

   下表为 0X3808~0X380B 寄存器的功能说明

   | 寄存器地址 | 名称         | 默认值 | 功能描述                                   |
   | ---------- | ------------ | ------ | ------------------------------------------ |
   | 0x3808     | TIMING DVPHO | 0x00   | bit[3:0]: 输出图像 X 方向尺寸大小的高 4 位 |
   | 0x3809     | TIMING DVPHO | 0x10   | bit[7:0]: 输出图像 X 方向尺寸大小的低 8 位 |
   | 0x380A     | TIMING DVPVO | 0x00   | bit[2:0]: 输出图像 Y 方向尺寸大小的高 3 位 |
   | 0x380B     | TIMING DVPVO | 0x04   | bit[7:0]: 输出图像 Y 方向尺寸大小的低 8 位 |

   注意:当输出大小窗口与预缩放窗口比例不一致时,图像将进行缩放处理(会变形),仅当两者比例一致时,输出比例才是 1:1(正常)。

5. OV5640 输出图像时序

   ​	在图像显示领域,会将一些特定的分辨率命一个名词,下表为常见的分辨率定义和其对应的实际像素矩阵大小:

   | 定义  | 分辨率    | 定义  | 分辨率   |
   | ----- | --------- | ----- | -------- |
   | QSXGA | 2592*1944 | XGA   | 1024*768 |
   | QXGA  | 2048*1536 | SVGA  | 800*600  |
   | UXGA  | 1600*1200 | VGA   | 640*480  |
   | SXGA  | 1280*1024 | QVGA  | 320*240  |
   | WXGA+ | 1440*900  | QQVGA | 160*120  |
   | WXGA  | 1280*800  |       |          |

   **行时序**

   ​	下图为 OV5640 在 DVP 接口模式下输出一行图像数据的时序图:

   ![OV5640行时序](asset/OV5640-11.png)

   ****

   下图为 OV5640 在 DVP 接口模式下输出一帧图像(QSXGA)数据的时序图:

   ![OV5640场时序](asset/OV5640-12.png)

   **总结**

   1. 所有信号(HREF、VSYNC、DATA)都是在 PCLK 的下降沿变化,应用处理器应该在 PCLK的上升沿取用数据。

   2. VSYNC 作为帧同步信号,默认是高电平有效,也就是说,每当新一帧图像开始输出之前,VSYNC 都会呈现一段时间的高电平。而在正常输出图像数据期间,VSYNC 信号保持低电平。在 VSYNC 变为低电平后的第一个 HREF 高电平期间输出的数据就是新一帧图像的第一行数据。

   3. HREF 作为行数据有效信号,在其为高电平时,DATA 数据线上每个时钟周期输出一个新的数据。

      

6. OV5640 输出图像格式

   ​	对于 OV5640 的图像输出数据格式,在不同的应用领域有所不同。在嵌入式系统如单片机、ARM 处理器系统中,一般常用 2 种输出方式: RGB565 和 JPEG。在图像处理系统中,一般常用 RGB565 模式和 YUV422 格式。而在图像采集系统中,为了充分保留图像传感器采集到的原始图像信息,会采用 RAW 格式输出。

   ​	当输出 RGB565、YUV422、RAW 格式数据的时候,时序完全就是上面两幅图介绍的关系。而当输出数据是 JPEG 数据的时候,同样也是这种方式输出(所以数据读取方法一模一样),不过 PCLK 数目大大减少了,输出的数据是压缩后的 JPEG 数据,输出的 JPEG 数据以: 0XFF,0XD8 开头,以 0XFF,0XD9 结尾,且在 0XFF,0XD8 之前,或者 0XFF,0XD9 之后,会有不定数量的其他数据存在(一般是 0),这些数据我们直接忽略即可,将得到的0XFF,0XD8~0XFF,0XD9 之间的数据,保存为.jpg/.jpeg 文件,就可以直接在电脑上打开看到图像了。

### 1.6 OV5640 典型工作模式配置

1. 基本初始化配置

   ​	基本初始化配置表以 800*480@30FPS 的 RGB565 输出模式为例。

2. 修改信号极性

   ​	为得到正确的图像,OV5640 传感器的视频信号极性与基带芯片或 ISP 必须设置成一致。例如,默认状态下, OV5640 的 VSYNC 是低电平有效,即 VSYNC 信号在输出图像时为低电平。而我们常见的图像捕获系统中,往往以 VSYNC 信号为高电平代表图像数据有效,此时就需要设置 SYNC 信号的极性为高电平有效。OV5640 可以通过设置地址为 0x4740 号寄存器的值来设置信号的极性,具体设置方法如下表所示:

   | 信号名称 | 寄存器中数据位 | 功能描述                                                     |
   | -------- | -------------- | ------------------------------------------------------------ |
   | VSYNC    | 0x4740.bit0    | 1 – Vsync 为高时输出数据有效<br />0 – Vsync 为低时输出数据有效 |
   | HREF     | 0x4740.bit1    | 0 – Href 为高时输出数据有效<br/>1 – Href 为低时输出数据有效  |
   | PCLK     | 0x4740.bit5    | 1 – 数据在下降沿输出<br/>0 – 数据在上升沿输出                |

3. 修改帧率

   ​	OV5640 的图像输出帧率可以通过修改地址为 **0x3035、0x3036、0x3037** 的寄存器的值来修改,该寄存器实际上是设置了 OV5640 片上 PLL 的各种分频和倍频系数,例如在典型配置模式下,当输入时钟 XCLK 的信号频率为 24MHz 时, 设置 0x3035 寄存器的值为 0x21 可设置输出帧率为 30fps,设为 0x41 可设置输出帧率为 15fps、设为 0x81 可设置输出帧率为 7.5fps。

4. 图像镜像翻转

   ​	因为 OV5640 是一款 BSI 图像传感器, 成像光线是从芯片背面射入的,所以原始生成的图像看起来是左右相反的,故此需要对图像做镜像处理使其显示正常。设置镜像和翻转功能是通过设置寄存器 **0x3820** 和 **0x3821** 的值实现的。上电时,0x3820 的值默认为 0x40,0x3821的值默认为 0x00。0x3820 寄存器的 bit2 和 bit1 分别设置 ISP 和传感器的翻转,0x3821 寄存器的 bit2 和 bit1 分别设置 ISP 和传感器的镜像。

5. 调整图像尺寸

   ​	前面提到,设置输出图像尺寸可以通过设置 ISP 在传感器上的开窗,预缩放偏移和输出图像大小窗口。最常用的是设置输出图像大小窗口设置,地址为 0x3808 和 0x3809 的寄存器设置输出图像的高度,地址为 0x380a 和 0x380b 的寄存器设置输出图像的宽度。例如,需要设置输出图像大小为 800*480 分辨率,则设置输出图像高度寄存器的值为 0x0320(800d),设置输出图像宽度寄存器的值为 0x01e0(480d)。即设置:

   ```
   0x3808 = 0x03; // DVPHO 800
   0x3809 = 0x20; // DVPHO
   0x380a = 0x01; // DVPVO 480
   0x380b = 0xe0; // DVPVO
   ```

6. 调整图像输出模式

   ​	OV5640 输出图像制式支持多种制式,如 RGB、YUV、RAW。而 RGB 制式又包括 RGB888、RGB565、RGB555、RGB444 模式等,YUV 制式包括 YUV444、YUV422、YUV420 模式等,而每个模式下,又根据输出像素的各个字节代表的不同意义,又分为多种模式,例如对于 RGB565 模式,连续的两个字节代表一个像素的颜色值,在代表一个像素点的 2 个字节数据中,哪几位代表红色分量,哪几位代表绿色分量,哪几位代表蓝色分量,也是通过寄存器可以设置的。具体模式设置是通过 0x4300 这个寄存器设置的。

   ​	0x4300 寄存器共 8 位,其中 bit[7:4]设置图像输出模式,bit[3:0]设置每个模式下输出像素内容的顺序。下表为 bit[7:4]的值和对应的输出模式的关系。

   表:调整图像输出格式寄存器

   ![调整图像输出格式寄存器](asset/OV5640-13.png)

   ​	当设置了图像输出模式后,可以通过设置该寄存器的 bit[3:0]来设置输出图像的顺序。例如,对于 RGB565 模式(bit[7:4]=0x6),设置 bit[3:0]为不同的值则可以实现不同的输出序列,如下表所示:

   ![OV5640-14](asset/OV5640-14.png)

   ​	一般是使用 RGB 或 BGR 序列,即设置寄存器的 bit[3:0]的值为 0x0 或 0x1。

   ​	下表为 YUV422 模式(bit[7:4]=0x3)时 bit[3:0]的值与对应的输出序列的关系:

   ![OV5640-15](asset/OV5640-15.png)

7. 彩条测试模式

   ​	通过设置地址为 0x503d 寄存器中相应位的值,可以设置 OV5640 输出的图像内容是传感器采集到的图像还是测试信号发生器模块产生的测试信号。

   ​	0x503d 寄存器的最高位 bit7 为测试信号发生器的开关控制位,设置为 1 即可开启测试信号发生器。 bit[1:0]为测试信号类型选择寄存器不同的值可以选择不同的测试模式,如彩条(Color Bar)、棋盘格(Color square)。



## 2. 程序设计

### 2.1 整体说明

​	OV5640 在正常工作之前必须通过配置寄存器进行初始化,而配置寄存器的 SCCB 协议和 I2C 协议在写操作时几乎一样,所以我们需要一个 I2C 驱动模块。为了使 OV5640 在期望的模式下运行并且提高图像显示效果,需要配置较多的寄存器,这么多寄存器的地址与参数需要单独放在一个模块,因此还需要一个寄存配置信息的 I2C 配置模块。

ov5640 整体框图如下

![ov5640 整体框图](asset/OV5640-16.png)

表：OV5640 各模块功能介绍

| 模块名称    | 功能描述              |
| :---------- | --------------------- |
| ov5640_top  | OV5640 顶层模块       |
| i2c_ctrl    | i2c 驱动模块          |
| ov5640_cfg  | OV5640 寄存器配置模块 |
| ov5640_data | OV5640 图像采集模块   |

​	由上述图表可知,第一部分的 OV5640 相关模块包含 4 个子模块,首先是 ov5640_top模块,这一模块作为 ov5640 部分的顶层模块,内部实例化 3 个子功能模块,连接各子模块对应信号,外部对摄像头进行相关配置并接收摄像头采集的数据信息;ov5640_cfg 模块,是寄存器配置模块,内部包含对 ov5640 摄像头的配置信息;i2c_ctrl 模块,i2c 协议与SCCB 协 议 几 乎 无 差 别 , 使 用 i2c 协 议 代 替 SCCB 接 口 协 议 向 ov5640 摄 像 头 写 入ov5640_cfg 模块内部包含的寄存器配置信息;ov5640_data 模块,是 ov5640 摄像头的图像采集模块,将摄像头传入的图像数据处理后写入 DDR3 SDRAM。

### 2.2 图像采集模块

**模块框图**

​	图像采集模块的主要功能是接收并拼接 OV5640 摄像头传入的图像数据，具体见下图和表

![OV5640图像采集模块框图](asset/OV5640-17.png)

![OV5640模块输入输出信号简介](asset/OV5640-18.png)

**第一部分:输入信号说明**

​	模块输入信号有 5 路,输入时钟信号为 ov5640_pclk,由 ov5640 摄像头自带晶振产生并 传 入 , 频率24MHz , 作为模块工作时钟; 复位信号sys_rst_n , 低电平有效;ov5640_vsync 为摄像头采集图像的场淘宝信号,可类比与 VGA 场同步信号,只在同步阶段为高电平,其他时刻保持低电平;ov5640_href 为行有效图像使能信号,信号只有采集图像行有效显示区域为高电平,其他时刻为低电平;最后的 ov5640_data 为摄像头采集到的图像数据,读者要注意的是,ov5640_data 位宽为 8bit,采集的图像数据分两次传入模块,先传入图像数据高字节,下个时钟周期传入低字节。

**第二部分：帧有效信号**

​	系统上电后,摄像头刚采集的前几帧图像数据不太稳定,根据手册要求要先舍弃前 10 帧图像,之后的图像才能用于显示。为了舍弃前 10 帧图像,我们需要声明几个变量。首先要舍弃前 10 帧图像,需要一个计数器来计数,声明计数器 cnt_pic 对输入图像帧数进行计数;接下来就要考虑以什么为标志进行计数,这时我们想到每帧图像的传入,帧同步信号必不可少,那么声明帧同步信号寄存信号 ov5640_vsync_dly,此信号延后帧同步信号一个时钟周期,利用两信号产生帧同步信号下降沿 pic_flag,作为帧计数器cnt_pic 的计数标志信号,该信号每拉高一次计数器自加 1;声明帧有效信号 pic_valid,当计数器计数到第 10 帧,pic_flag 为高电平,将帧有效信号拉高并始终保持高电平。

**第三部分:图像数据拼接相关信号**

​	前面说到,像素点图像信息并不是在一个时钟周期传入,而是在第一个时钟周期传入高 8 位,下一个时钟周期传入低 8 位,所以要正确显示图像就需要对传入图像数据进行拼接。实现数据拼接就需要声明若干变量。

​	我们的想法是需要先声明一个寄存器对图像数据的高字节进行数据缓存,待低字节数据传入时,将图像数据进行拼接。首先声明寄存器 pic_data_reg 对高字节数据进行缓存;声明标志信号 data_flag 控制数据缓存与拼接,在 ov7725_href 信号有效时,标志着输入图像数据有,data_flag 不断取反,当其为低电平时对高字节数据进行缓存,当其为高电平时对数据进行拼接。将拼接后的数据赋值给 data_out_reg。

**第四部分:数据输出信号波形图**

​	拼接后的数据做一下缓存输出写入做回数据缓存的 DDR3 SDRAM,有数据同时传出的还有同步的使能信号。

### 2.3 寄存器配置模块

​	要想 OV5640 摄像头正常工作,需要先对摄像头进行寄存器配置,即向摄像头寄存器
写入对应指令。

**模块框图**  

![OV5640-19](asset/OV5640-19.png)

![OV5640-20](asset/OV5640-20.png)

**模块功能**

- 保存通过I²C接口向OV5640摄像头写入的251个预定义的寄存器配置值，并依次输出
- 控制配置流程：等待上电稳定 → 逐个寄存器配置 → 完成标志

### 2.4 I2C总线控制模块

​	I2C 总线控制模块的主要功能是按照 I2C 协议对 OV5640 配置寄存器执行数据读写操作。

**模块框图**  

![OV5640-21](asset/OV5640-21.png)

![OV5640-22](asset/OV5640-22.png)

​	由图表可知,I2C 驱动模块包括 13 路输入输出信号,其中输入信号 8 路、输出信号 5 路。输入信号中,sys_clk、sys_rst_n 是必不可少的系统时钟和复位信号;wr_en、rd_en 为读写使能信号,由数据收发模块生成并传入,高电平有效;i2c_start 信号为单字节数据读/写开始信号;与 i2c_start 信号同时传入的还有数据存储地址 byte_addr 和待写入字节数据wr_data;当写使能 wr_en 和 i2c_start 信号同时有效,模块执行单字节数据写操作,按照数据存储地址 byte_addr,向从机对应地址写入数据 wr_data;当读使能信号 rd_en 和i2c_start 信号同时有效,模块执行单字节数据读操作,按照数据存储地址 byte_addr 读取从机对应地址中的数据;前文中我们提到, I2C 设备存储地址有单字节和 2 字节两种,为了应对这一情况,我们向模块输入 addr_num 信号,当信号为低电平时,表示 I2C 设备存储地址为单字节,在进行数据读写操作时只写入数据存储地址 byte_addr 的低 8 位;当信号为高电平时,表示 I2C 设备存储地址为 2 字节,在进行数据读写操作时要写入数据存储地址 byte_addr 的全部 16 位。

​	输出信号中,i2c_clk 是本模块的工作时钟,由系统时钟 sys_clk 分频而来,它的时钟频率为串行时钟 i2c_scl 频率的 4 倍,时钟信号 i2c_clk 要传入数据收发模块作为模块的工作时钟 ; 输出给数据收发模块的单字节数据读 / 写结束信号i2c_end,高电平有效,表示一次单字节数据读/写操作完成;rd_data 信号表示自从机读出的单字节单字节数据,输出至数据收发模块;i2c_scl、i2c_sda 分别是串行时钟信号和串行数据信号,由模块产生传入从机对应引脚。

 I2C 读/写操作状态转移图如下。

![OV5640-23](asset/OV5640-23.png)

### 2.5 顶层模块

​	在顶层模块内部实例化个子功能模块,外部进行工程输入输出信号的连接，只需连接对应端口即可。

